
### Array

http://blog.csdn.net/sunny2038/article/details/9002531

- 同一个NumPy数组中所有元素的类型必须是相同的。
- 属性

```
NumPy数组的维数称为秩（rank），一维数组的秩为1，二维数组的秩为2

在NumPy中，每一个线性的数组称为是一个轴（axes），秩其实是描述轴的数量。比如说，二维数组相当于是两个一维数组，其中第一个一维数组中每个元素又是一个一维数组。所以一维数组就是NumPy中的轴（axes），第一个轴相当于是底层数组，第二个轴是底层数组里的数组。而轴的数量——秩，就是数组的维数。

ndarray.ndim：数组的维数（即数组轴的个数），等于秩。最常见的为二维数组（矩阵）。

ndarray.shape：数组的维度。为一个表示数组在每个维度上大小的整数元组。例如二维数组中，表示数组的“行数”和“列数”。ndarray.shape返回一个元组，这个元组的长度就是维度的数目，即ndim属性。

ndarray.size：数组元素的总个数，等于shape属性中元组元素的乘积。

ndarray.dtype：表示数组中元素类型的对象，可使用标准的python类型创建或指定dtype。另外也可使用前一篇文章中介绍的NumPy提供的数据类型。

ndarray.itemsize：数组中每个元素的字节大小。例如，一个元素类型为float64的数组itemsiz属性值为8(float64占用64个bits，每个字节长度为8，所以64/8，占用8个字节），又如，一个元素类型为complex32的数组item属性为4（32/8）。

ndarray.data：包含实际数组元素的缓冲区，由于一般通过数组的索引获取元素，所以通常不需要使用这个属性。
```

- 方法

```
zeros((3,4)):可创建一个全是0的数组
ones((2,,3,4)):可创建一个全为1的数组
empty((3,4)):创建一个内容随机并且依赖与内存状态的数组。
默认创建的数组类型(dtype)都是float64。
可以用d.dtype.itemsize来查看数组中元素占用的字节数目。
ones((2,3,4),dtype=int16)#手动指定数组中元素类型  
arange():返回一个数列形式的数组 arange(10, 30, 5)  #以10开始，差值为5的等差数列
array**x, 每个元素的x次方
```

- 自定义结构

```
student= dtype({'names':['name', 'age', 'weight'], 'formats':['S32', 'i','f']}, align = True)  

使用dtype函数创建，在第一个参数中，'names'和'formats'不能改变，names中列出的是结构中字段名称，formats中列出的是对应字段的数据类型。S32表示32字节长度的字符串，i表示32位的整数，f表示32位长度的浮点数。最后一个参数为True时，表示要求进行内存对齐。

a= array([(“Zhang”, 32, 65.5), (“Wang”, 24, 55.2)], dtype =student) 
```

- axis

```

  axis=0就是最外层的数组，最外层共有3个数组，每个是个2*2的二维数组
  [[[5 2]
    [4 2]]
   [[1 3]
    [2 3]]
   [[1 1]
    [0 1]]]
  X.sum(axis=0) # 对三个二维数组相加
  array([[7, 6],
         [6, 6]])
  X.sum(axis=1)
  array([[9, 4],
         [3, 6],
         [1, 2]])
  X.sum(axis=2)
  array([[7, 6],
         [4, 5],
         [2, 1]])
```

- 索引

```
  多维数组可以每个轴有一个索引。这些索引由一个逗号分割的元组给出。
  b  
  array([[ 0, 1, 2, 3],  
             [10, 11, 12, 13],  
             [20, 21, 22, 23],  
             [30, 31, 32, 33],  
             [40, 41, 42, 43]])  
  b[2,3]  
  23  
  
  b[0:5, 1] # 每行的第二个元素  
  array([ 1, 11, 21, 31, 41]) 
  
  b[: ,1] # 与前面的效果相同  
  array([ 1, 11, 21, 31, 41])  
  
  b[1:3,: ] # 每列的第二和第三个元素  
  array([[10, 11, 12, 13],  
             [20, 21, 22, 23]])  
```



- 默认

```
当少于提供的索引数目少于轴数时，已给出的数值按秩的顺序复制，确失的索引则默认为是整个切片：
b[-1] # 最后一行，等同于b[-1,:]，-1是第一个轴，而缺失的认为是：，相当于整个切片。
b[i]中括号中的表达式被当作i和一系列:，来代表剩下的轴。NumPy也允许你使用“点”像b[i,...]。
点(...)代表许多产生一个完整的索引元组必要的分号。如果x是秩为5的数组(即它有5个轴)，那么:　　　
  x[1,2,...] 等同于 x[1,2,:,:,:],  
  x[...,3] 等同于 x[:,:,:,:,3]
  x[4,...,5,:] 等同 x[4,:,:,5,:]　
```

- 多维数组的遍历是以是第一个轴为基础的
- 改变shape

```
- a.ravel() # 平坦化数组  
- reshape()的参数是个tuple,可以实现维度提升
  a.reshape((2,3))：有返回值，所谓有返回值，即不对原始多维数组进行修改；
- a.resize(2,3)：无返回值，所谓有返回值，即会对原始多维数组进行修改；
```



### tile

tile(A,reps)

假定A的维度为d,reps的长度为len

当d>=len时，将reps长度补足为d，即在reps前面加上d-len个1。

将A按照与reps的一一对应的方式copy

```
>>> a=[[1,2],[2,3]]
>>> tile(a,2)
array([[1, 2, 1, 2],
       [2, 3, 2, 3]])
这里a的维度为2，reps长度为1（仅仅是1个int类型数据）
则将reps长度补足为2，结果为reps = [1,2](这里也可以写成reps=(1,2)，都无妨的)
进行copy操作，从低维进行.数组a为a[2][2]
一维copy操作：copy两次。a[0]变为[1,2,1,2],a[1]变为[2,3,2,3]
二维copy操作，copy1次。a变为[[1,2,1,2],[2,3,2,3]]
```

